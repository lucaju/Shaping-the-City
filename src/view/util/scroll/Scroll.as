package view.util.scroll {		//imports	import com.greensock.TweenMax;		import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TransformGestureEvent;	import flash.geom.Point;		import util.DeviceInfo;		import view.util.scroll.Roll;
		public class Scroll extends Sprite {				public const VERTICAL:String = "vertical";		public const HORIZONTAL:String = "horizontal";				//properties		private var _target:Sprite;		private var _mask:Sprite;		private var _wMax:Number = 0;		private var _hMax:Number = 0;		private var _ratePage:Number;		private var _prev_mouse_pos:Point = new Point(0,0);		private var _speed:Point = new Point(0,0);		private var roll:Roll;		private var track:Track;				private var _direction:String = VERTICAL;		private var _offset:Number = 0;				private var friction:Number = 0.98;		private var _color:uint = 0x000000;				/**		 * [Exclude(name="Sprite", kind="method")] 		 * Constructor.		 * <p>You have to set some attributes to make the scroll works</p>		 * <p>Required:</p>		 * <p>TARGET: Set the target using the function target.</p> 		 * <p>MASK: Set the target mask using the function maskContainer.</p> 		 * <br />		 * <p>Optional:</p>		 * <p>DIRECTION: Set the sroll direction using the function direction. You can choose between "vertical" and "horizontal". If you don't set this, the scroll will the default VERTICAL direction</p>		 * <p>COLOR: Set Roll and Track colors usinf the function color. The default is 0x000000 (Black).</p>		 * 		 * <p>The construct add an event. Whenever it is added to the screen, it will add the other iteractive events.</p>		 */		public function Scroll() {						this.addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);					}				//---------  getters  --------				/**		 * Target. Returns the current scroll target. 		 * @return 		 * 		 */		public function get target():Sprite {			return _target;		}				/**		 * Direction. Returns the current scroll direction. 		 * @return 		 * 		 */		public function get direction():String {			return _direction;		}				/**		 * Offset. Returns the current offset used in the scroll.		 * @return Number		 * 		 */		public function get offset():Number {			return _offset;		}				/**		 * Color. Returns the current color used on Roll and Track objects. 		 * @return uint		 * 		 */		public function get color():uint {			return _color;		}				/**		 * getRatePage. Returns the current page rate in the scroll.		 * @return 		 * 		 */		public function getRatePage():Number {			return _ratePage;		}				//---------  setters  ---------  		/**		 * Set scroll direction.		 * 		 * <p>Values: "vertical" or "horizontal".</p> 		 * <p>Default: "vertical".</p>		 * 		 * @param value:String		 * 		 */		public function set direction(value:String):void {			_direction = value;		}				/**		 * Set offset position where the scroll is an relation to the target's parent.		 * 		 * @param value:Number		 * 		 */		public function set offset(value:Number):void {			_offset = value;		}				/**		 * Define Roll and Track colors.		 *  		 * @param value:uint		 * 		 */		public function set color(value:uint):void {			_color = value;		}				/**		 * Target: Set scroll target. 		 * 		 * <p>It automatically calls ratePage function if mask is set.</p>		 * 		 * @param value:Sprite		 * 		 */		public function set target(value:Sprite):void {			_target = value;					if (_mask != null) ratePage();			}				/**		 * Mask: Set shape to mask the target.		 * 		 * <p>In VERTICAL direction, MASK height defines hMax.</p>		 * <p>In HORIZONTAL direction, MASK width defines wMax.</p>		 * 		 * <p>It automatically calls ratePage function if target is set.</p>		 *  		 * @param value:Sprite		 * 		 */		public function set maskContainer(value:Sprite):void {			_mask = value;						if (direction == "vertical") {				_hMax = _mask.height;			} else {				_wMax = _mask.width;			}						if (_target != null) ratePage();					}				/**		 * Rate Page: Calculate the page rate.		 * 		 * <p>For VERTICAL direction, it divides the TARGET HEIGHT by MASK HEIGHT.</p>		 * <p>For HORIZONTAL direction, it divides TARGET WIDTH by MASK WIDTH.</p>		 * 		 * <p>It automatically calls scrollSize function.</p>		 */		private function ratePage():void {						if (direction == "vertical") {				_ratePage = _target.height / _mask.height;			} else {				_ratePage = _target.width / _mask.width;			}						scrollSize();		}				/**		 * Scroll Size: Resize roll and track.		 * 		 * <p>For VERTICAL direction, TRACK heiht is resized to match hMax and ROLL height is resized to match hMax/ratePage</p> 		 * <p>For HORIZONTAL direction, TRACK width is resized to match wMax and ROLL width is resized to match wMax/ratePage</p>		 * 		 */		private function scrollSize():void {						if (direction == "vertical") {				if (roll) roll.height = _hMax / _ratePage;				if (track) track.height = _hMax;			} else {				if (roll) roll.width = _wMax / _ratePage;				if (track) track.height = _wMax;			}		}								/**		 * 		 * @param e		 * 		 */		protected function addedToStageHandler(e:Event):void{						addEvents();		}				protected function addEvents():void {			this.parent.addEventListener(MouseEvent.MOUSE_DOWN, _handleMouseDown);						this.parent.addEventListener(TransformGestureEvent.GESTURE_PAN, _handlePan);						//roll.addEventListener(MouseEvent.MOUSE_DOWN, drag);						//Mouse Down active on the roll						//stage.addEventListener(MouseEvent.MOUSE_UP, stop);						//Mouse Up wherever						//track.addEventListener(MouseEvent.CLICK, trackClick);					//Mouse Clicked on track		}				public function init():void {			// track			track = new Track();			track.height = _wMax;			//addChild(track);									// Roll			roll = new Roll(color);			roll.init(direction);			roll.width = _wMax / _ratePage;			addChild(roll);						if (direction == "vertical") {				this.y = target.y;				this.x = target.width - this.width;			} else {				this.x = target.x;				this.y = _mask.height - this.height;			}		}				protected function _handleMouseDown(event:MouseEvent):void {			_speed.y = 0;			_speed.x = 0;			_tweenComplete();
		}				protected function _handlePan(e:TransformGestureEvent):void {									if (direction == this.VERTICAL)  {								if (DeviceInfo.os() != "Mac") {					_target.y += 2 * (e.offsetY);					roll.y = _target.y / _ratePage;				} else {					_target.y -= 2 * (e.offsetY);					roll.y = -_target.y / _ratePage;				}							} else if (direction == this.HORIZONTAL) {								if (DeviceInfo.os() != "Mac") {					_target.x += 2 * (e.offsetX);					roll.x = _target.x / _ratePage;				} else {					_target.x -= 2 * (e.offsetX);					roll.x = -_target.x / _ratePage;				}							}						switch (e.phase) {								case "begin":					this.removeEventListener(Event.ENTER_FRAME, throwobject);					TweenMax.killChildTweensOf(this);					roll.alpha = 1;					track.alpha = 1;										if (_speed.y * -e.offsetY < 0) _speed.y = 0;					if (_speed.x * -e.offsetY < 0) _speed.x = 0;										break;								case "update":					this.removeEventListener(Event.ENTER_FRAME, throwobject);										if (DeviceInfo.os() != "Mac") {						_speed.x += e.offsetX;						_speed.y += e.offsetY;					} else {						_speed.x -= e.offsetX;						_speed.y -= e.offsetY;					}										break;								case "end":					this.parent.mouseChildren = false;					this.addEventListener(Event.ENTER_FRAME, throwobject);					break;			}		}				/*				private function drag(e:MouseEvent):void {			TweenMax.killChildTweensOf(this);			//_mask.enableBitmapMode();						roll.alpha = 1;			track.alpha = 1;						var rect:Rectangle = new Rectangle(0,0,0,_hMax - roll.height)			roll.startDrag(false, rect);			this.addEventListener(Event.ENTER_FRAME, _inertial);			}				private function _inertial(e:Event):void {			TweenMax.to(_target, .3, {y:-roll.y * _ratePage+1, onUpdate:_mask.update});		}				private function stop(e:MouseEvent):void {			_mask.disableBitmapMode();			_tweenComplete();			roll.stopDrag();			this.removeEventListener(Event.ENTER_FRAME, _inertial);		}				private function trackClick(e:MouseEvent):void {			roll.alpha = 1;			track.alpha = 1;						var clickPos:Number = mouseY;														//capture the mouse position			var yPosition:Number;																//define final position						//define the scroll orientation			var orientation:int = 0;																					if (clickPos > roll.y) {				orientation = 1;			} else if (clickPos < roll.y) {				orientation = -1;			}						//boundaries			yPosition = _target.y - (_hMax  * orientation);						if(yPosition > 0) {																	//Top				yPosition = 0;			} else if(yPosition < -_target.height + _hMax) {								//bottom				yPosition = -_target.height + _hMax;			}						//animations			//TweenMax.to(_target, .3, {y:yPosition, onStart:_mask.enableBitmapMode, onUpdate:_mask.update, onComplete:_mask.disableBitmapMode});			TweenMax.to(_target, .3, {y:yPosition, onUpdate:_mask.update});								TweenMax.to(roll, .3, {y:- yPosition / _ratePage, onComplete: _tweenComplete});				}				*/						private function throwobject(e:Event):void {						//drirection			switch (direction) {								case this.VERTICAL:										//test boundaries					if (_target.y > 0 + offset) {						TweenMax.to(_target, .3, {y:0 + offset});						TweenMax.to(roll, .3, {y:0, onComplete: _tweenComplete});						_speed.y = 0;					} else if (_target.y < -_target.height + _hMax) {						TweenMax.to(_target, .3, {y:-_target.height + _hMax});						TweenMax.to(roll, .3, {y:_hMax - roll.height, onComplete: _tweenComplete});						_speed.y = 0;					} else {												//move						_target.y += _speed.y;						roll.y += - _speed.y/_ratePage;												//apply friction						_speed.y *= friction;												//limit inertia						if (_speed.y > -.8 && _speed.y < .8) _speed.y = 0;											}															//end inertia					if (_speed.y == 0) _tweenComplete();										break;												case this.HORIZONTAL:										//test boundaries					if (_target.x > 0 + offset) {						TweenMax.to(_target, .3, {x:0 + offset});						TweenMax.to(roll, .3, {x:0, onComplete: _tweenComplete});						_speed.x = 0;					} else if (_target.x < -_target.width + _wMax) {						TweenMax.to(_target, .3, {x:-_target.width + _wMax});						TweenMax.to(roll, .3, {x:_wMax - roll.width, onComplete: _tweenComplete});						_speed.x = 0;					} else {												//move						_target.x += _speed.x;						roll.x += - _speed.x/_ratePage;												//apply friction						_speed.x *= friction;												//limit inertia												if (_speed.x > -.5 && _speed.x < .5) {							_speed.x = 0;							_tweenComplete();						}					}										//end inertia					if (_speed.x == 0) this.removeEventListener(Event.ENTER_FRAME, throwobject);											break;			}								}				private function _tweenComplete():void {			this.removeEventListener(Event.ENTER_FRAME, throwobject);			//_mask.disableBitmapMode();			this.parent.mouseChildren = true;			TweenMax.to(roll, .3, {alpha:0, delay: .6});			TweenMax.to(track, .3, {alpha:0, delay: .4});		}			}	}

